"""
Rose Teague and Jarvist Frost 05/07/2018
propagators.jl
Let's get those Ïˆ moving.
Define Functions:

- DipolesFromDensity
- SiteEnergyFromDipoles
- AdiabaticPropagation
- UnitaryPropagation
- TimeDependentPropagation

"""

#-------------------------------------------------------------------------------
function SiteEnergyFromDipoles(dipoles,S,E)
    #=
    Calculate site-energies for sites, from potential generated by dipoles at
    other sites.
    ---------------
    Inputs
    ---------------
    dipoles - dipole matrix (e*a_0)
    S - previous site energies (Hartree)
    ---------------
    Outputs
    ---------------
    S - Updated site energies for TightBinding Hamiltonian (Hartree)
    =#

    for i in 1:N
        for j in 1:N
            if (j==i)
                # avoid infinity in self energies
                continue
            end
            # Contribution to site energy (1 e- at site) from dipoles
            S[i]+=sign(j-i)*dipoles[j]/(i-j)^2
        end
    end
    S = dipolestrength*S
    H = diagm(E,-1)+diagm(S)+diagm(E,1)
    return S,H
end


#-------------------------------------------------------------------------------
function FieldFromDensity(density)
    #=
    Calculate field at each site from the charges as every other site
    --------------
    Inputs
    --------------
    density - electron density found from the wavefunction |Psi|^2
    --------------
    Outputs
    --------------
    Field - electrostatic field

    =#
    Field=zeros(N)
    for i in 1:N
        Fsum=zero(eltype(density)) # Calculate total field at each
        for j in 1:N
            if (j==i)
                continue # avoid infinite self energies
            end
            Fsum+=sign(i-j)*density[j]/(i-j)^2 # How much do the dipoles respond to the electron density?
        end                         # check power of r for field from point charge.
        Field[i]=Fsum/r^2
    end
    return Field
end


#-------------------------------------------------------------------------------
function UpdateDipole(Field, dipole, dipolestrength)
    #=
    Update dipole matrix by soliving the equation E = \alpha*p
    ----------
    Inputs
    ----------
    Field  - electrostatic field from electron density at every other site
    dipole - current dipole matrix to be updated
    dipolestrength - Contains the exponential decay of the dipole response
                     (exp(-TimeStep*DecayRate))
    ----------
    Outputs
    ----------
    dipole - updates dipole moments induced by electrostatic fields
    =#

    alphainv = -1*ones(N)
    # diagonal elements from polarizability of sites
    M = diagm(alphainv)
    n=0
    # Off-diagonal elements from separation between sites
    for i in 1:N
        for j in 1:N
            if (j==i)
                continue
            end
            M[n+j] = 1/(r*(j-i))^3
        end
        n+=N
    end
    new_dipole = \(M,Field)
    # Update dipoles with a fraction from the new dipole matrix
    dipole += dipolestrength*(new_dipole-dipole)
    return dipole

end

#-------------------------------------------------------------------------------
function AdiabaticPropagation(S,dipoles,E)
    #=
    "Build Hamiltonian from Dipoles (via SiteEnergyFromDipoles), diagonalise and
    update dipoles responding to ground state electron density. A wrapper function."
    -----------------
    Inputs
    -----------------
    S       - (Hartree)
    dipoles -
    E       - (Hartree)
    -----------------
    Outputs
    -----------------
    S       -
    psi     -
    Density -
    dipoles -
    =#

    S,H = SiteEnergyFromDipoles(dipoles,S,E)
    psi=eigvecs(H)[:,1] # gnd state

    println("Adiabtic State energy: <psi|H|psi> = ",psi'*H*psi)
    KE=diagm(E,-1)+diagm(E,+1)
    PE=diagm(S)
    println("KE: <psi|KE|psi> = ",psi'*KE*psi)
    println("PE: <psi|PE|psi> = ",psi'*PE*psi)

    density=psi.^2
    Field=FieldFromDensity(density)
    dipoles = UpdateDipole(Field, dipoles, dipolestrength)

    return S,psi,density,dipoles
end


#-------------------------------------------------------------------------------
function UnitaryPropagation(dipoles,S,E,psi,dt,slices::Int=1)
    #=
    "Self-consistent response of the lattice with unitary (time dependent)
    evolution of the wavefunction. "
    ---------------
    Inputs
    ---------------
    dipoles -
    S       -
    E       -
    psi     -
    dt      -
    slices  -
    ---------------
    Outputs
    ---------------
    S       -
    psi     -
    density -
    dipoles -


    =#
    S,H=SiteEnergyFromDipoles(dipoles,S,E)

    H=diagm(E,-1)+diagm(S)+diagm(E,+1)

    En=eigvals(H)[1]
    println("First Eigval (adiabatic): ",En)

#    psi=eigvecs(H)[:,1] # gnd state; reproduces adiabtic state (eigval) above
    println("State energy: <psi|H|psi> = ",psi'*H*psi)
    KE=diagm(E,-1)+diagm(E,+1)
    PE=diagm(S)
    println("KE: <psi|KE|psi> = ",psi'*KE*psi)
    println("PE: <psi|PE|psi> = ",psi'*PE*psi)

    psi=TimeDependentPropagation(psi,H,dt,slices=slices,decompose=false,verbose=false)

    density=abs(psi.^2) # can be Complex!

    Field=FieldFromDensity(density)
    dipoles = UpdateDipole(Field, dipoles, dipolestrength)

    return S,psi,density,dipoles
end

#-------------------------------------------------------------------------------
function TimeDependentPropagation(psi,H,dt;slices::Int=1,decompose::Bool=false,verbose::Bool=false) # propagate directly using full Hamiltonian=T+V
    #= Decompose unitary evolution into this many slices

    Propagate Wavefunction directly with Hamiltonian and time dependent Schrodinger equation.

    Psi (N) is the wavefunction; H the Hamiltonian (NxN); dt the length of time to
    propgate along; slices is how many slices to decompose the Unitary operator
    into; verbose sets the display of info on the unitary nature of U, whether U*U'
    ~= I.

    --------------
    Inputs
    --------------
    psi         - wavefunction
    H           - TightBinding Hamiltonian (Hartree)
    dt          - Time Step (0.02418884326505 fs)
    slices      - sub-time step (0.02418884326505 fs)
    decompose   - Perform Trotter Expansion (Boolean)
    verbose     - Print unitary transformation (Boolean)
    --------------
    Outputs
    --------------
    psi         - wavefunction

    =#
    dt=dt/slices
    U=eye(H) # identiy matrix same size + type as H

    for i=1:slices
        if decompose
            S,J=Decompose_H(H) # split into diagonal and off-diag terms
            # Trotter decomposition
            U*=expm(-im*J*dt/2)*expm(-im*S*dt)*expm(-im*J*dt/2)
        else
            U*=expm(-im*H*dt)
        end
    end

    psi=U*psi # OK; we've built out unitary time evolution operator U, now apply it

    if verbose # for debugging / introspection
        @printf(" (matrix-squaring slices: %d) U: \n",slices)
        display(U)
        println("\n\tUU': (in any sane world this should be = Identity )\n")
        display(U*U') # Why you no unitary?

        println("\nPre normalised Norm of psi: ",norm(psi))
    end

    normalisation=sqrt(sum(abs(psi.^2))) # Nb: for normalisation of WAVEFUNCTION; must SQUAREROOT the sum of density
    println("Normalising Psi by dividing by: ",normalisation)
    psi=psi/normalisation # Normalise propagated wavefunction
    return psi
end

#-------------------------------------------------------------------------------
function TimeDependentPropagation(psi,H,dt,E)
    #=
    propagate using eigenvalue
    "Propagate wavefunction directly from eigenergy, and time dependent Schrodinger equation."

    -------------
    Inputs
    -------------
    psi     - wavefunction
    H       - TightBinding Hamiltonian (Hartree)
    dt      - Time step (0.02418884326505 fs)
    E       - Energy Eigenvalues (Hartree)
    -------------
    Outputs
    -------------
    psi     - wavefunction
    =#
    psi=exp(-im*E*dt)*psi
    println("Pre normalised Norm of psi: ",norm(psi))
#    psi/=norm(psi*psi') # Normalise propagated wavefunction
    return psi
end
