# propagators.jl
# Let's get those ψ moving.

"""
    SiteEnergyFromDipoles(dipoles,S,J)

Calculate site-energies for sites, from potential generated by dipoles at
other sites.

dipoles - dipole matrix (e*a_0)
S - previous site energies (Hartree)

returns:
S - Updated site energies for TightBinding Hamiltonian (Hartree)
"""
function SiteEnergyFromDipoles(dipoles,S,J)
    S = zeros(N)
    for i in 1:N
        S[i]+=-field_ext*(r*i)
        for j in 1:N
            if (j==i)
                # avoid infinity in self energies
                continue
            end
            # Contribution to site energy (1 e- at site) from dipoles
            S[i]+=sign(j-i)*dipoles[j]/(r*(i-j))^2
        end
    end
    S = S
    #H = diagm(J,-1)+diagm(S)+diagm(J,1)
    return S
end

"""
    FieldFromDensity(density)

Calculate field at each dipole site from the charge density at every other site

density - electron density found from the wavefunction |Psi|^2

returns:
Field - electrostatic field
"""
function FieldFromDensity(density)
    field=zeros(N)
    for i in 1:N
        Fsum=zero(eltype(density)) # Calculate total field at each
        for j in 1:N
            if (j==i)
                continue # avoid infinite self energies
            end
            Fsum+=-sign(i-j)*density[j]/(i-j)^2 # How much do the dipoles respond to the electron density?
        end                         # check power of r for field from point charge.
        field[i]=Fsum/r^2
    end
    return field
end


"""
    FieldFromDipole(dipoles)

Calculate field at each dipole site from the induced dipole-induced dipole
interations at every other site

dipoles - existsing induced dipole

returns:
FieldDI - electrostatic field
"""
function FieldFromDipole(dipole)
    FieldDI=zeros(N)
    for i in 1:N
        FDIsum=zero(eltype(dipole)) # Calculate total field at each
        for j in 1:N
            if (j==i)
                continue # avoid infinite self energies
            end
            FDIsum+=-9*sign(j-i)*dipole[j]/((r*(j-i))^7) # How much do the dipoles respond to the electron density?
        end
        FieldDI[i]=FDIsum
    end
    return FieldDI
end

"""
    UpdateDipole(field, dipole, dampening, alpha)

Update dipole vector by solving the equation E = \alpha*p

field  - electrostatic field from electron density at every other site
dipole - current dipole vector to be updated
dampening - Contains the exponential decay of the dipole response (exp(-TimeStep*DecayRate))
alpha - polarisability of sites (assuming uniformity)

returns:
dipole - updates dipole moments induced by electrostatic fields
"""
function UpdateDipole(field, dipole, dampening, alpha=1.0)
    alphainv = 1*ones(N)/alpha#*dipolestrength
    # diagonal elements from polarisability of sites
    M = diagm(alphainv)
    n=0
    # Off-diagonal elements from separation between sites
    for i in 1:N
        for j in 1:N
            if (j==i)
                continue
            end
            M[n+j] = 1/(r*(j-i))^3
        end
        n+=N
    end
    new_dipole = \(M,field)
    # Update dipoles with a fraction from the new dipole matrix
    dipole += dampening*(new_dipole-dipole)
    return dipole
end

"Original JMF function; dipoles by exponential relaxation to t=+∞ solution."
function dipoles_by_relaxation(dipoles,density,dampening)
    for i in 1:N
        relaxeddipole=zero(eltype(density)) # fix type instability; initialise to zero in the supplied type of density
        for j in 1:N
            if (j==i)
                continue # avoid infinite self energies
            end
            relaxeddipole+=density[j]/(i-j)^1 # How much do the dipoles respond to the electron density?
        end

        dipoles[i]+=dampening*(relaxeddipole-dipoles[i]) # Approaches the infinite time limit via Zeno's dichotomy
    end
    return dipoles
end

"Print state energy"
function print_state_energy(m::TightBindingModel)        
    println("Adiabatic State energy: <psi|H|psi> = ",m.psi'*m.H*m.psi)
    KE=diagm(m.J,-1)+diagm(m.J,+1) 
    PE=diagm(m.S) 
    println("KE: <psi|KE|psi> = ",m.psi'*KE*m.psi) 
    println("PE: <psi|PE|psi> = ",m.psi'*PE*m.psi)
end

"""
    AdiabaticPropagation(S,dipoles,E)

Build Hamiltonian from Dipoles (via SiteEnergyFromDipoles), diagonalise and
update dipoles responding to ground state electron density. A wrapper
function.

Time is ill-defined in this simulation - it takes you towards equilibrium.

S       - (Hartree)
dipoles -
E       - (Hartree)

returns
S       -
psi     -
Density -
dipoles -
"""
function AdiabaticPropagation!(m::TightBindingModel, verbose::Bool=true,dipole_int::Bool=false)
    S,H = SiteEnergyFromDipoles(m.dipoles,m.S,m.J)
    m.psi=eigvecs(m.H)[:,1] # gnd state

    if verbose print_state_energy(m) end

    m.density=m.psi.^2

    field=FieldFromDensity(density)+field_ext
    dipoles = UpdateDipole(field, dipoles, dampening)

    if dipole_int
        FieldDI = FieldFromDipole(dipoles)
        dipoles = UpdateDipole(Field+FieldDI, dipoles, dampening)
    end

    return S,H,psi,density,dipoles
end

"""
    UnitaryPropagation!(dipoles,S,E,psi,dt,dampening; slices::Int=1)

Self-consistent response of the lattice with unitary (time dependent)
evolution of the wavefunction.
"""
function UnitaryPropagation!(m::TightBindingModel, dt; slices::Int=1, verbose::Bool=true)
    S=SiteEnergyFromDipoles(m.dipoles,m.S,m.J)

    copy!(m.S,S)
 #   m.H=diagm(m.J,-1)+diagm(m.S)+diagm(m.J,+1)

    En=eigvals(m.H)[1]
    println("First Eigval (adiabatic): ",En)

#    psi=eigvecs(H)[:,1] # gnd state; reproduces adiabtic state (eigval) above
    if verbose print_state_energy(m) end
    
    TimeDependentPropagation!(m,dt, slices=slices,decompose=false,verbose=false)

    copy!(m.density,abs.(m.psi.^2)) # can be Complex!

    Field=FieldFromDensity(m.density)+field_ext
    dipoles = UpdateDipole(Field, m.dipoles, m.dipole_strength)

    return true
end

"""
    TimeDependentPropagation(psi,H,dt;slices::Int=1,decompose::Bool=false,verbose::Bool=false)

Propagate Wavefunction directly with Hamiltonian and time dependent Schrodinger equation.

Psi (N) is the wavefunction; H the Hamiltonian (NxN); dt the length of time to
propgate along; slices is how many slices to decompose the Unitary operator
into; verbose sets the display of info on the unitary nature of U, whether U*U'
~= I.

psi         - wavefunction
H           - TightBinding Hamiltonian (Hartree)
dt          - Time Step (0.02418884326505 fs)
slices      - sub-time step (0.02418884326505 fs)
decompose   - Perform Trotter Expansion (Boolean)
verbose     - Print unitary transformation (Boolean)

returns:
psi         - wavefunction
"""
function TimeDependentPropagation!(m,dt;slices::Int=1,decompose::Bool=false,verbose::Bool=false,test::Bool=false) # propagate directly using full Hamiltonian=T+V
    dt=dt/slices
    U=eye(m.H) # identiy matrix same size + type as H

    for i=1:slices
        if decompose
            S,J=Decompose_H(m.H) # split into diagonal and off-diag terms
            # Trotter decomposition
            U*=expm(-im*J*dt/2)*expm(-im*S*dt)*expm(-im*J*dt/2)
        else
            U*=expm(-im*m.H*dt)
        end
    end

    copy!(m.psi, U*m.psi) # OK; we've built out unitary time evolution operator U, now apply it

    if verbose # for debugging / introspection
        @printf(" (matrix-squaring slices: %d) U: \n",slices)
        display(U)
        println("\n\tUU': (in any sane world this should be = Identity )\n")
        display(U*U') # Why you no unitary?

        println("\nPre normalised Norm of psi: ",norm(psi))
    end

    normalisation=sqrt(sum(abs.(m.psi.^2))) # Nb: for normalisation of WAVEFUNCTION; must SQUAREROOT the sum of density
    #println("Normalising Psi by dividing by: ",normalisation)
    copy!(m.psi, m.psi/normalisation) # Normalise propagated wavefunction

    return true 
end

"""
    TimeDependentPropagation(psi,H,dt,E)

Propagate (in time) using eigenvalue

psi     - wavefunction
H       - TightBinding Hamiltonian (Hartree)
dt      - Time step (0.02418884326505 fs)
E       - Energy Eigenvalues (Hartree)

returns:
psi     - wavefunction
"""
function TimeDependentPropagation!(m::TightBindingModel,dt,E)
    m.psi=exp(-im*E*dt)*m.psi
    println("Pre normalised Norm of psi: ",norm(m.psi))
    m.psi/=norm(m.psi*m.psi') # Normalise propagated wavefunction
    return psi
end

